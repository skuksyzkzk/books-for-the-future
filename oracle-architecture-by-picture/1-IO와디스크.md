# 1. I/O와 디스크의 관계

## 😁 들어가기전 

이 책 전반적으로 소개되는 오라클의 필수 키워드 3가지를 알기 전 선수 지식으로 처리량과 응답시간에 대해 기본적으로 알아야한다. 간단히 정리해보자! 

### 처리량과 응답시간

<img width="509" alt="image" src="https://github.com/user-attachments/assets/38ab1c0c-6535-4626-981a-6ec63c9fab31" />

사진 속 여러 지표를 기준으로 각 최적화에 사용된다.

#### **처리량**

처리량은 시스템이 단위 당 처리할 수 있는 작업량을 의미한다.

보통 초당 처리될 수 있는 트랜잭션의 수를 나타낸 TPS(Transactions Per Second)나 초당 요청 처리 수(RPS: Requests Per Second) 등으로 표현된다.

처리량이 높을수록 시스템이 더 많은 작업을 처리할 수 있으며, 병렬 처리 능력과 하드웨어 자원 활용이 중요한 역할을 한다.

**예제**

웹 서버가 초당 100개의 HTTP 요청을 처리할 수 있다면, 이 서버의 처리량은 100 RPS(Requests Per Second)라고 할 수 있다.

데이터베이스가 초당 500개의 트랜잭션을 수행할 수 있다면, 500 TPS(Transactions Per Second)의 처리량을 가진다.

#### **응답시간**

사용자가 요청을 보낸 시점부터 응답을 받을 시점까지 걸리는 총 시간을 의미한다.

> 응답시간 = 지연시간(Latency) + 처리시간(Processing Time)

**예제**

사용자가 웹사이트에서 버튼을 클릭했을 때, 서버에서 응답을 받아 브라우저에 표시되는 데 200ms가 걸린다면 응답 시간은 200ms이다.

데이터베이스에서 특정 데이터를 조회하는 데 1.2초가 걸린다면 응답 시간은 1.2초이다.

---

# 🪟 1. 오라클을 이해하기 위한 필수 키워드


오라클을 포함한 DBMS의 구조는 복잡합니다. 복잡한 이유는 이 3가지를 충족시킬려고 하기 때문입니다.
 
3가지는 상반된 성향이 있어서 만족시키기가 어렵습니다.

### 1. 병렬 처리를 가능케 하고 높은 처리량을 실현한다.

이것도 병렬 처리할 때는 모순된 처리가 발생하지 않도록 Lock이 필요한데 이로인해서 성능이 저하되는 경우도 있다.

### 2. 응답 시간(Response Time)을 중시한다.

### 3. 커밋(Commit)한 데이터는 지킨다.


 "커밋한 데이터는 지킨다"를 만족하기 위해선 커밋한 순간 디스크에 기록해야된다. 데이터 무결성 기준에선 순간마다 기록해야 되기때문이다.

하지만 그렇게되면 디스크 I/O가 증가해서 응답속도가 느려진다. 그래서 나중에 몰아서 한번에 하게되면 장애 발생시 무결성이 깨질수 있기 때문이다.

---
# 🪟 2. 오라클과 디스크

오라클은 DBMS다. 오라클 입장에서 데이터베이스는 오라클이 디스크에 저장하고 관리하는 데이터를 의미한다. 즉 디스크에서 데이터를 읽고,쓰고를 하는 것이다.

물론 이건 HDD경우에 해당하고 SSD는 디스크가 없기에 다르긴하다. 

> HDD VS SSD
>
> HDD는 자기 디스크에 데이터를 저장하고, SDD는 플래시 메모리에 데이터를 저장한다.
>
> 그렇기에 디스크에서의 탐색과 회전대기시간이 없기에 SSD가 더 빠른 것이다.

## 디스크의 구조

디스크는 디스크와 헤드, 액추에이터로 구성된다.

디스크는 거의 항상 회전하고있다.


# 🪟 3. 디스크의 동작

![image](https://github.com/user-attachments/assets/d722cb79-074e-4231-9722-69ce2a089fcb)


### 탐색과 회전 대기 시간

데이터를 읽기 위해서 헤드를 움직이는 것이 "탐색" 이다. 원하는 위치로 헤드를 움직여놓고 원하는 위치가 다가올때 까지 기다리는 시간이 "회전 대기 시간" 이다.

**우리가 메모리 접근은 나노초(ns)로 하지만 디스크의 탐색과 회전대기시간은 ms초 단위가 걸린다.**

> 그렇기에 DISK I/O를 가장 줄여야 되는 것이다.

`탐색시간 + 회전대기시간 = 10ms`

`디스크의 전송시간 = 20MB/초`

## 어떻게 I/O 대기 시간을 줄일까? 

![image](https://github.com/user-attachments/assets/cc0425a2-8daa-4454-9c55-5e7ac554c938)

### 시퀀셜 액세스 (Sequential Access)

순서를 따라서 시작점부터 마지막까지 전부 읽거나 쓰는 것을 의미한다.

연속된 블록을 읽고, 헤드 이동이 매우 적기에 오히려 빠르다.

`풀스캔할 때 시퀀셜 액세스 발생`

테이블 크기가 1GB라면 데이터를 가져오는 데 시퀀셜 엑세스로 

$$1,000 MB / 20MB = 50초$$

50초나 걸리게됩니다. 너무 느리죠 그래서 나온 개념이 **InDex**입니다.

### INDEX

책에서 무엇을 찾고 싶을 때, 처음부터 읽는 것이 아니라 책의 색인을 사용해서 원하는 페이지로 바로 찾아가는 것. 이게 인덱스의 개념입니다.

인덱스에는 키값과 그 키가 존재하는 주소(ROWID)가 저장되어있습니다.

**인덱스 예시**

1. 디스크에서 인덱스를 불러옴
2. 인덱스를 조사해 키값과 대응되는 주소값(ROWID)확인
3. 주소를 토대로 디스크에서 데이터 읽음
4. 데이터속에서 내가 찾는 데이터를 SELECT 

또한 인덱스는 B-Tree라는 트리구조로 저장된다.

### 랜덤 액세스 (Random Access)

데이터를 순차적으로 처음부터 마지막까지 전부 읽는 방식이 아닌, 원하는 블록만 읽는 것이다.

원하는 블록만 읽기에 디스크 I/O가 적어서 무조건적으로 좋아보이지만 꼭 그런것도아니다.

원하는 블록을 읽기위해서 탐색과 회전대기시간이 걸리기 때문이다.

**하지만 SSD에서는 헤드 이동이 없기에 랜덤 액세스가 매우 빠르다**


예시로 오라클 블록크기를 8KB, 1초마다 탐색할 수 있는 횟수를 100회라고하면 1초마다 800KB밖에 읽어올 수 없습니다. 이는 그냥 가만히 20MB를 가져오는 것에 비해 25분의 1에 불과합니다..

그렇기에 실제로 OTLP시스템 즉 많은 단말에서 실시간으로 읽거나 쓰는 작업을 하고 즉시 결과를 회신해야하는 시스템에서는 IOPS가 중요합니다.

`I/O per Second`

대부분은 100 ~ 200회 정도이기에 한두개 디스크 로는 부하기 집중적으로 발생시 요청 들어오는 것을 탐색이 못 따라잡아 병목이 발생합니다.

## 부록: 인덱스를 사용하는 것이 유리한 경우는 전체 데이터의 15% 미만일 경우

예를 들어서 하나의 데이터를 뽑아야한다면 당연히 인덱스를 쓰는 게 빠르다.

하지만 모든 데이터를 본다고 할 때 책을 처음부터 읽을 때, 매번 인덱스를 보고 찾아가면 늦을 것이다.

**그럼 만약 데이터가 50%라면?**

상황에 따라 다른 것이다. 이건 명확히 구분 짓기 힘들다.

우리의 핵심은 디스크에서 랜덤 액세스가 시퀀셜 액세스보다 효율성이 떨어진다는 것이다.

그렇기에 초당 탐색 가능한 디스크 횟수와 디스크 전송 속도 이런 것에 따라서 다른 것.

실제로는 캐시에 데이터가 보관된 경우도 있다. 그와 반대로 인덱스 데이터를 디스크에서 읽어 오는 경우도 있으니 상황마다 다른 것.

### 하지만 15 ~ 25% 까지는 랜덤 액세스 즉 인덱스 사용이 더 효율적이라고 한다.

# 🪟 4. 데이터를 보증하는 디스크

데이터는 오라클의 프로세스가 비정상적으로 멈춰도 유지 되어야합니다. 엑셀 같은 프로그램은 저장 후 모든 데이터는 컴퓨터를 끄면 사라지지만, DB는 그러면 안되는 거죠.

그렇기에 DBMS에서는 커밋한 데이터는 지키는 것입니다.

커밋을 하게되면 그때 디스크에 기록하는 것이죠. 그러면 매번 commit을 입력해야되니 느리지 않을까 라고 생각할 수 있지만 속도를 빠르게하는 장치가 마련되어 있답니다..


## 부록 : 시퀀셜이란?

`db file scattered read = 시퀀셜 액세스`


`db file sequential read = 랜덤 액세스`


반대라고 생각되지만 이 용어는 읽어온 블록을 어떻게 메모리에 배치하는지에 따라 표현되는 것입니다.

즉 시퀀셜 액세스는 여러블록을 읽어서 메모리상 연속되지 않게 분산된 형태로 놓이고

랜덤 액세스는 한번에 한개를 가져와 메모리 공간에 연속적으로 놓는 것이죠.


# 요약

`디스크가 회전하는 이미지`

`탐색시간과 회전대기시간이 IO에 미치는 영향`

`인덱스로 인해 해당데이터에 빠르게 접근 가능하다`




---
#### 참고 자료
[참고자료-처리량과 응답시간](https://velog.io/@ymh92730/%EC%9B%B9%EC%84%9C%EB%B2%84-%EC%84%B1%EB%8A%A5-%EC%98%AC%EB%A6%AC%EA%B8%B0%EC%B2%98%EB%A6%AC%EB%9F%89-%EC%84%B1%EB%8A%A5)

[참고자료-Little's Law](https://performance.tistory.com/4)

[참고자료](https://loosie.tistory.com/843)

# 4. SQL 분석과 공유풀

# ⚠️ 1. SQL문과 프로그래밍 언어의 차이

SQL문을 처리하는 방법을 생성하는데 CPU는 오랜시간을 투자해야합니다. 그래서 SQL을 처리하는 방법의 생성과 처리 방법을 캐싱하는 방법을 배워보겠습니다.

우리가 아는 일반적인 프로그래밍언어와 SQL문의 차이는 바로 **절차**입니다.

우리가 프로그래밍 언어를 작성할때는 어떻게 변수를 처리하고 분기를 타고 Loop를 돌려서 결과를 만들게 하죠.

하지만 SQL문은 그런 절차가 없이 그냥 어떤 데이터인지 어떤 조건과 관계를 가지고 있는지만 기술할 뿐입니다.

**그래서 이러한 SQL문을 분석하고 실행계획이라는 처리방법(절차)을 생성하는 것은 옵티마이저(Parser)가 해줍니다**

어떤 인덱스를 탈지, 테이블을 풀스캔할 건지 등


# ✨ 2. 서버 프로세스와 분석

서버 프로세스는 고객의 SQL 처리를 최우선적으로 수행하는 직원이라고 설명했던 것처럼 SQL Parsing도 수행합니다.

오라클에서 Parsing이란 SQL문을 분해해서 어떤 요소로 구성되어 있는지를 조사하고 어떤식으로 처리할지 생각하는 것입니다.


## 📕 규칙기반과 비용기간

### 규칙기반
10g부터는 규칙기반을 지원하지 않습니다만 규칙기반은 오라클이 미리 우선순위로 정해놓은 규칙에 따라서 실행계획을 선택하는 것입니다.

유연성이 떨어지고, 데이터가 많아지거나 분포가 불균형할 시 성능이 많이 떨어지죠.

### 비용기반

비용기반은 말 그대로 처리시간이나 IO횟수가 가장 적다고 생각하는 처리방법을 최상으로 잡는 알고리즘입니다.

이러한 처리방법을 생각하기 위해서 **통계정보**를 사용하는데 이 통계정보는 Analyze라고 불리는 작업을 통해 얻습니다.

SQL문이 들어올때마다 통계정보를 생성하면 느리기에 미리 생성하는 것이죠.

### 통계정보

#### 1. SQL문의 정보
- 어떤 테이블의 어떤 데이터인지
- 어떤 조건(where)
- 어떤 관게 : 어떻게 조인하는지 

#### 2. 초기화 파라미터
- 단일 I/O로 읽어올 수 있는 블록의 수

#### 3. 옵티마이저 통계
- 테이블 통계(로우 및 블록 정보)
- 컬럼 통계(컬럼 값 및 데이터 분포정보)
- 인덱스 통계(인덱스 깊이 등)

대표적으로 위의 3가지 정보를 사용해 비용을 계산하여 최적의 실행계획을 찾습니다.

# 🤔 3. 만약 실행계획이 최적이 아니라면?

실행계획이 최적인지는 어떻게 판단할까요? 

기본적으로는 모든 처리방법의 비용을 계산해서 선택하는 것이지만 이렇게되면 테이블 10개를 조인한다 했을 경우, 경우의 수가 너무 많아지게됩니다.

그렇기에 DBMS에서 좋지 않은 실행계획을 선택하는 것은 선택할 수 있는 실행계획의 수가 너무 많고, 결국 실행계획은 **예측**에 불과한 것이기 때문입니다.

## 실행계획이 중요한 이유
```oracle
SELECT * FROM A,B WHERE A.ID = B.ID AND A.Value = 1 AND B.Value = 1;
```

이 경우 만약 A테이블에 1,000만건의 데이터가 있고, B테이블에 100건의 데이터만 있다고 생각해봅시다. 또한 A테이블 전부 Value가 1이라고 가정해볼까요.

그럼 이런 경우 A테이블에 접근하면 결국 천만건의 데이터를 가져오고, 그 중 B의 value가 1인 값 하나를 찾기위해서 천만번 꺼내오도록 시도할 것입니다.

그렇기에 B먼저 접근해서 value가 1인 하나의 ID를 가져와서 A테이블과 비교하면 2번만에 끝나기에 압도적으로 빠른거죠

이처럼 어디 테이블부터 접근할지에 관한 것같은 실행계획은 매우 중요합니다.

> 📗 어댑티브 쿼리 최적화 : Oracle 12에 도입
>
> 이것은 실행계획 결정시 사전에 수집한 정보가 아닌 동적으로 수집하게 해줍니다. 하지만 그렇기에 OLTP같이 실행시간이 짧은 SQL문이 다수 수행되는 환경에서는 좋지 않습니다.


# 🗽4. 공유 풀

CPU에서 SQL 분석 처리는 큰 규모의 작업이란게 이해가 되셨을 것입니다.

그렇기에 공유 풀이라는 실행계획을 재사용하기 위한 공간을 사용해서 CPU자원을 절약합니다.

> 실제로 데이터의 처리에 시간이 걸리는 SQL문은 분석 처리에 사용하는 CPU가 상대적으로 적기에 신경을 덜 쓰게 됩니다.
>
> 예시) 대량의 데이터를 가져오는 SELECT 문 

서버 프로세스는 요청이 들어올시 공유플을 확인해서 똑같은 sql 문이면 과거의 실행계획을 그대로 써서 시간을 절약하는 것이죠.

공유풀도 프로세스간 공유되어야하므로 SGA에 존재합니다. SGA의 대부분은 버퍼캐시지만 남은 일부는 공유 풀로 사용되죠.

공유 풀은 라이브러리 캐시나 딕셔너리 캐시와 같은 영역으로 나뉩니다.

라이브러리 캐시에 SQL 실행 계획이 있고, 딕셔너리 캐시에는 통계정보의 캐시나 sql실행에 필요한 메타정보를 저장하죠.

## 그러면 어떻게 같은 SQL인지 파악할까요?

**해시 알고리즘**

해시 알고리즘을 사용해서 sql마다 ID를 부여합니다. 결국 그렇기에 대문자 소문자 이런것이 하나라도 다르면 해시값이 달라지는 것이죠.

그렇기에 만약 값이 다른 SQL을 반복해서 실행하고 싶을 때는 바인드 변수를 사용하는 것이 좋습니다.

**바인드 변수**

```pl/sql
VARIABLE empno NUMBER
EXEC :empno := 7788

SELECT * FROM EMP WHERE EMPNO = :empno;

```

바인드 변수를 쓰면 소프트 파스를 유도합니다. 소프트 파스가 해시 값을 요청해서 공유풀에 캐시되어 있는 계획을 찾아서 재사용하는 것입니다.

하드 파스는 공유풀에 실행계획이 없기에 새롭게 생성하는 것이죠.

###  ✨cursor?

실제로는 cursor라는 소프트 파스를 아예 수행안하고 SQL문을 실행하는 경우도 있습니다.

이게 성능은 제일 좋습니다.

# 🪟 5. 수치로 보는 분석

오라클에서는 스태츠팩(Statspack)이라는 표준 성능 진단 도구를 제공합니다. 설치해서 사용해야됩니다. 이것으로 CPU 사용량 중 분석을 위해 사용하는 CPU사용량이 절반이나 차지하네 이런것을 보고 바인드 변수 사용해야지 이런 분석을 할수있습니다.

하지만 10g이상 부터는 AWR이라는 분석 도구로 설치안하고 볼수 있습니다.

# 📚 요약

- SQL문에는 처리방법이 적혀있지 않기에 오라클 실행계획을 생성할 필요가 있다.
- 실행 계획의 좋고 나쁨에 따라서 성능이 크게 변한다.
- 실행 계획의 생성에 많은 CPU가 사용되기에 공유풀에 실행 계획을 캐시해두고 재활용해야된다.

## 어디서 사용할까?

결국 4장에 배운 지식으로 어떻게 실무에 적용될까?

### 실행 게획이 나쁘고 SQL문의 성능이 좋지 않을 경우

비용계산의 기초정보가 되는 통계정보가 제대로 수집되는지 확인한다. dbms_stats(또는 analyze 명령어)패키지를 사용해서 최신의 통계정보를 수집하면 좋은 실행계획을 만들수있다.

그래도 안된다면 옵티마이저의 판단이 좋지 않은 것이기에 **힌트나 Plan Stability** 기능을 사용해서 오라클에 지시를 내립니다.


### 하드 파스가 많으며, 분석에 사용하는 CPU양이 많을때

하드 파스가 만힉에 바인드 변수를 사용할 수 있는 지 확인합니다. 안된다면 CURSOR_SHARING이라고하는 초기화 파라미터 를 설정해서 바인드 변수를 설정한 것과 같은 동일한 효과를 얻어봅시다. 

> 이때는 PSR을 적용해야합니다.

### 크기에 관한 튜닝

공유 풀의 크기에 대한 튜닝은 쉽지않습니다. free memory 즉 미사용 메모리가 없어질때까지는 버리지 않기에 

-> 즉, 공간이 충분하면 굳이 지우지 않고 그냥 계속 유지한다는 거죠.


바인드 변수를 사용해서 소프트 파스로 처리되도록 해도 SQL문이 캐시로 밀려나서 하드 파싱 일어나는 경우가 존재합니다.

-> Shared Pool 공간이 부족해지면, Oracle은 오래된 SQL 실행 계획부터 제거(LRU)합니다.

이럴때는 공유풀의 크기를 늘리면 효과가 있습니다.


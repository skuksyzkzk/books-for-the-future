# 3. 캐시와 공유 메모리

# 🥸 1. 캐시가 필요한 이유

캐시가 필요한 이유는 디스크의 접근 속도가 느린 것을 극복하기 위함입니다. 디스크 접근하는 것은 밀리초가 걸리고 메모리의 접근은 NS가 걸리기 때문이다.

자주 사용하는 데이터를 캐시에 저장하고 디스크에서 읽어오는 것이 아닌 캐시 메모리에서 읽어오는 것입니다.

오라클의 버퍼 캐시(데이터 캐시)가 해당 역할을 합니다.

> TMI : **하지만 실제로 캐시에 없다면 캐시접근 + 디스크 접근이기에 최악의 경우는 시간이 더 오래 걸립니다**

# 😁 2. 블록 단위로 관리

오라클은 '블록' 단위로 데이터를 관리합니다. 정리용 상자로 생각하면 편한데 여러가지 물건을 보관하고 정리하는 것이죠. 옷은 옷 상자에 이런식으로 정리하는 것과 같습니다.

블록안에는 여러 ROW들이 존재합니다. 결국 하나의 데이터를 읽어 올려면 해당 블록을 읽어와야되는 것이죠.

**그래서 블록 전체가 캐시에 보관됩니다.**

![image](https://github.com/user-attachments/assets/6685764c-b0bb-4454-b283-eebd3726443e)

> 블록 크기는 2KB,4KB,8KB,16KB,32KB 중에서 선택이 가능합니다. 보통 캐시의 크기가 커짐에 다라 8KB를 선택합니다.

# 🗽 3. 캐시와 인덱스 

테이블 뿐 만 아니라 인덱스도 블록으로 구성되어있습니다. 인덱스를 한 블록에 보관할 수 없을 경우 여러개의 블록으로 구성합니다. 

인덱스가 3계층일 경우, 테이블의 한블록을 포함해서 데이터를 읽어올경우 총 블록 4개를 처리해야되므로 I/O가 4번 발생하게 됩니다. 그러면 캐시에 적재되지 않았을 경우 40밀리초가 걸리게되는 것입니다.

![image](https://github.com/user-attachments/assets/527b5701-4f88-4c9e-a700-215918972970)

하지만 CPU에서는 1.2밀리초만 사용하기에 캐시가 효과가 좋은 것이죠.

**인덱스도 캐시가 필요합니다**


# ✨ 4. 프로세스는 캐시를 공유한다.

프로세스마다 캐시를 가진다면 너무 낭비가 심해지고, 다른 프로세스에서 변경한 데이터는 못보는 등 문제가 생긴다.

그래서 **공유 메모리**를 사용해서 캐시를 공유한다.

프로세스는 PGA와 SGA를 사용한다.

![image](https://github.com/user-attachments/assets/5d255ed9-5cfc-40d6-aa79-cdfac49cb5cb)

### PGA

**Program Global Area**

각 사용자(프로세스)별로 사용하는 메모리로 해당 프로세스만 접근이 가능하다. 쿼리 실행속도 최적화에 영향을 준다.

각 프로세스의 SQL 실행 정보 저장 및 Order by, Group by 등 연산을 수행할 때 사용된다.

### SGA

**System Global Area**

여러 사용자(프로세스)들이 공유하는 메모리 영역입니다. 여기 부분을 변경하면 다른 사용자 입장에서도 전부 변경이 됩니다.

> 사실은 각 프로세스는 결국 하나의 메모리를 사용하고 있는 것입니다. 논리적으로 분리되어 있을 뿐 

### Lock

공유하는 메모리이기에 LOCK이 중요합니다. 안 그러면 하나의 데이터에 대해서 동시에 여러 사용자가 접근해서 작업 수행시 데이터 무결성이 깨질수 있기 때문입니다.

# 🤬 5. 공유 메모리

공유 메모리는 설정 파일 spfileXXXX.ora (XX는 데이터 식별 ID)에 버퍼 캐시의 크기를 결정하는 `DB_CACHE_SIZE` 라는 파라미터가 있습니다.

대부분은 메뉴얼따라서 설정하면 됩니다.

> 버퍼 캐시의 크기
>
> 버퍼 캐시 크기를 설정하는 것은 신중하게 해야됩니다. 버퍼 캐시 크기마다 물리읽기수를 예측하는 버퍼 캐시 어드바이저나 버퍼 캐시 히트율 같은 것을 참고해서 버퍼 캐시를 튜닝할 수도 있죠..
>
> 하지만 SGA는 버퍼 캐시 뿐만아니라 다른 메모리 영역도 존재하기에 오라클에서 자동으로 관리해주는 자동 공유 메모리 관리를 쓰는 것도 좋습니다.
>
> 여기서 필자는 DB_CACHE_SiZE를 하한으로 잡아놓고 자동 공유 메모리 관리 모드를 쓰는 것을 추천합니다. 왜냐하면 이렇게 하한을 설정해야 캐시 버퍼 영역이 다른 영역에 안 잡아 먹힌다고 합니다....


### 공유메모리는 어떻게 보일까?

공유 메모리는 특수한 메모리입니다. 각 프로세스가 실제로 사용하는 메모리 크기와 가상 메모리 크기가 나뉘게 되는 거죠.

그래서 오라클 프로세스의 메모리가 3GB로 여러개 띄어져 있는 것 같아도 실제론 3GB를 공유해서 전체가 그렇게 보이는 것 뿐입니다.

# 🪟 6. 버퍼 캐시를 정리하는 LRU알고리즘

버퍼 캐시는 더 자주 사용하는 데이터를 적재하기 위한 공간입니다. 그렇기에 사용되지 않는 데이터는 교체해줘야겠죠.

여기서 Least Recently Used 최근에 사용되지 않은 데이터 부터 버리는 알고리즘을 사용합니다.

하지만 데이터를 읽어오는 것 뿐만아니라 서버프로세스는 변경한 데이터도 캐시에 둡니다. 하지만 서버 프로세스는 데이터 기록은 하지 않죠.
![image](https://github.com/user-attachments/assets/ba7f4b59-80b8-405c-86e6-c5738ec89979)


그래서 여기서 백그라운드 프로세스의 `DBWR`이 수행합니다.

캐시에 기록된 데이터가 LRU알고리즘에 의해서 사라질 때 디스크에 기록하는 것이죠.

> 또한 풀스캔을 수행하면 버퍼 캐시에 저장이 안됩니다. 테이블 크기가 큰 테이블을 전체를 읽는 다면 버퍼 캐시에 저장이 안되는거죠.

# ⚠️ 7. 오라클뿐만아니라 OS나 스토리지도 생각하자.

OS도 캐시가 있고, 스토리지도 캐시가 있다. 특히 스토리지 캐시는 비싸고 유용하다. 캐시에 기록하고 나중에 디스크에 입력하면 되기에..

### OS 버퍼 캐시와 가상 메모리 차이

가상 메모리는 물리 메모리보다 더 많은 메모리를 사용할 수있게 해주는 것입니다.

메모리에서 자주 사용되지 않는 데이터는 디스크에 스왑영역을 할당하여 저장해둡니다.

사실 프로세스 몰래 넣어두니까 더 많은 메모리를 쓰는 것 처럼보이는 것입니다.

그러기에 최근에 사용안한 데이터이기에 디스크에 옮겨 놓았던 것을 읽을 경우 디스크에서 읽어오기에 오래걸리게 되죠..

캐시와 가상 메모리는 결국 반대로 동작하는 것입니다.

> 참고로 물리 메모리의 페이지를 디스크에 기록하는 것이 페이지 아웃, 디스크 -> 물리 메모리가 페이지 인입니다.

**버퍼는 디스크에 빠르게 접근하기 위해 메모리의 일정 부분을 할당하는 것**

**가상 메모리는 더 많은 물리 메모리를 쓰기 위해서 디스크의 일정부분을 할당하는 것**

둘이 정확히 반대입니다.

# 요약 

결국 이 파트는 오라클의 캐시와 메모리에 관해 설명했습니다. 이로 인해 구조 설계와 튜닝에서 유용하게 사용할 수 있겠죠.

## 질문

**오라클에 같은 성능 테스트를 반복해서 수행합니다. 이때 캐시 정리하기 위해 오라클을 재기동했는데, 다음 테스트에서 왜 성능이 앞도적으로 좋게 나왔을 까요?**

-> 답은 OS에도 캐시가 존재하기때문입니다.

# 참고 

[오라클책그림](https://jwdeveloper.tistory.com/12)

# 6. 커넥션과 서버 프로세스의 생성

## 서문

오라클과 오라클을 사용하는 애플리캐이션이 같은 서버에서 구동되는 경우는 흔치 않고 거의 없다.

둘 사이는 네트워크로 통신하며 애플리케이션에서 통신과 관련된 코드를 수정함으로써 성능 개선을 할 수 도있다.


## 📲 Socket


### Socket이란?

>서버와 클라이언트의 IP 주소, 포트 번호, 연결 상태 등을 기록해놓은 하나의 파일이다.

소켓은 프로세스 간 통신을 위한 인터페이스로, 네트워크 상에서 데이터를 주고받기 위한 소프트웨어 객체입니다. 각 클라이언트와 서버가 소켓을 통해 데이터를 송수신하며, 각 클라이언트는 고유한 소켓 객체를 생성하여 서버와 연결을 유지합니다.

소켓은 프로세스 간 통신에 사용되는 양쪽 endpoint이다.

### 📞 소켓을 설명하는 비유: 전화 통화

#### 전화기
전화기(소켓)는 통신을 위한 도구입니다. 두 사람이 전화 통화를 하려면 서로 전화기를 가지고 있어야 하듯이, 소켓도 통신을 위해서 필요한 도구입니다. 각 전화기에는 고유의 번호(IP 주소 + 포트 번호)가 있어, 다른 사람과 통화하려면 이 번호를 알아야 합니다.

#### 전화선
 전화선(TCP/IP)은 통신이 이루어지는 경로입니다. 전화기와 전화기 사이를 연결해주는 물리적 매체가 전화선이라면, 소켓과 소켓을 연결하는 네트워크 통신 경로가 TCP/IP입니다.

#### 전화번호
 전화번호는 IP 주소 + 포트 번호를 의미합니다. 전화번호가 각 집과 연결되는 것처럼, 서버의 IP 주소와 포트 번호는 클라이언트가 서버와 연결하기 위한 고유 주소입니다. 예를 들어, 인터넷에 연결된 웹 서버는 보통 IP 주소 192.168.1.1과 포트 80을 통해 통신합니다.

#### 통화 (연결)
 통화는 서버와 클라이언트 간의 연결을 의미합니다. 클라이언트는 전화번호를 알고 서버에 전화를 걸듯이, 클라이언트가 서버의 IP 주소와 포트 번호를 알고 연결을 시도합니다. 서버는 연결 요청을 받으면, 전화(소켓)를 받듯이 소켓 객체를 생성하여 응답합니다.

#### 통화 종료
 전화가 끝나면 전화를 끊는 것처럼, 소켓 통신도 데이터를 다 주고 받은 후 연결을 종료합니다.

---

**⚠️ TCP/IP Socket과 Web Socket은 다르다!!**


### 🪟 웹소켓 통신이 필요한 이유

실시간 서비스, 예를 들어 MTS같은 서비스는 매초마다 서버로 부터 응답을 받아야한다. 이때 마다 HTTP통신으로 1초마다 서버에 요청을 보내서 받는 것은 매우 귀찮으므로 이에 해결책으로 대표적 2가지 방법이 있다.

> HTTP 1.1 이하에서는 클라이언트의 요청없이는 서버에서 메시지를 못보낸다.


### Pooling 

클라이언트가 서버에 주기적으로 요청을 보내는 것.

- 요청 보내는 주기 만큼 지연생김.
- 불필요한 요청도 그냥 보내짐 주기에 따라서 보내지기에.

### Long Pooling 

미리 클라이언트가 요청을 보내놓고 요청을 가지고 있는 서버 단에서 업데이트가 생기면 다시 요청을 반환해주는 방식이다. Pooling의 단점을 개선했다.
- 하지만 서버단의 부담이 커짐
- 여러 클라이언트와 연결을 유지해야되기에 문제가 생긴다.
- HTTP에서 요청과 응답에 ㅗ함되는 헤더 정보의 양도 매번 부담

## 🗽Web Socket

대표적으로 많이 사용하는 방식이다. HTTP 1.1 이하에서는 단방향 통신만 가능하지만, **WebSocket에서는 양방향 통신이 가능하다**

HTTP보다 헤더가 작고 오버헤드가 적기떄문에 효율적인 통신이 가능하다. 이 통신은 한쪽이 다른쪽에게 통신을 종료하자고 할 때까지 지속됩니다.

#### 비정상적인 종료를 감지하는 법

- 지정된 시간동안 메시지가 없을시 확인 패킷을 보낸다.
- ping pong 프레임을 주기로 주고 받아서 연결 확인


**이처럼 웹소켓은 하나의 연결을 끝까지 유지하고 그 과정에서 작은 자원을 소모해서 Long Pooling만큼 서버에 부하를 주지도 않는다.**

## 🤝 Web Socket 핸드쉐이크 

**클라이언트 -> 서버**
```http
GET /chat HTTP/1.1
Host: example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
```
**서버 -> 클라이언트**
```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

👉 핸드셰이크가 성공하면 WebSocket 연결이 유지되며, 이후부터는 WebSocket 프레임을 사용하여 양방향 실시간 통신 가능!

**101 Switching**


## 🆚 TCP/UDP socket VS Web Socket 

둘의 계층이 다릅니다. OSI 7계층에서 TCP/UDP는 4계층에 속하고 Web Socket은 7계층인 애플리케이션 계층에 속합니다.

websocket은 TCP 소캣을 기반으로 작동한다. 그러기에 데이터의 순서와 신뢰성이 보장된다는 것이다.

### ⚠️ Web Socket의 한계

- 로드 밸런서가 있는 서버의 경우 조심하자
- 메시지크기의 제약 
  - 대용량의 데이터는 분할해서 전달

- Web Socket의 기본 프로토콜인 WS는 통신이 암호화되어 있지않습니다.
- 그렇기에 SSL/TLS 인증서를 발급 받은뒤 이를 사용하여 WSS를 설정해야 된다.
- 또한 클라이언트가 결국 많아지면 연결해야되는 TCP 연결이 많아져서 서버에 부담이 가고, 네트워크 대역폭,CPU의 사용량이 높아진다.

> ⚠️로드 밸런싱 문제
>
> HTTP 요청은 짧은 요청-응답 방식이므로, 로드 밸런서는 매 요청마다 적절한 서버로 트래픽을 분배할 수 있음.
> 
> 하지만 WebSocket은 연결을 계속 유지하는 특성 때문에, 로드 밸런서가 연결을 임의로 다른 서버로 옮길 수 없음.
>
> 그래서 메시지 브로커를 사용해서 해결해야함.

## 📕 Web Socket의 대안 : Server-sent Events (SSE)

가볍게 보자면 클라이언트가 서버에 요청을 하는 구조가 아니라 서버가 매초마다 응답을 해주는 단방향 통신이다.

예를 들어서 실시간으로 소식이 올라오는 SNS페이지나, 주식 거래 서비스는 서버에서 응답을 지속적으로 보내주면 된다.

클라이언트가 SSE로 통신하자고 요청을 보내면 알겠다고 서버가 수신한다.

이후 서버가 메세지를 보내고 클라이언트는 메시지를 받아서 작업을 수행한다. 이 연결은 유지되며 만약에 연결이 끊어지면 클라이언트가 자동으로 재연결을 요청한다.

HTTP만을 통해서 이뤄지고 복잡한 코딩이나 설정이 필요없다.
그리고 서버에서만 메세지를 보내기 때문에 로드밸런싱 과정에서도 문제가 없다.

### 🤝 SSE handShake

**클라이언트 -> 서버**

```http
GET /stocks/stream HTTP/1.1
Host: example.com
Accept: text/event-stream
Connection: keep-alive
```

**서버 -> 클라이언트**
```http
HTTP/1.1 200 OK
Content-Type: text/event-stream
Cache-Control: no-cache
Connection: keep-alive

data: {"price": 105.3, "symbol": "AAPL"}

data: {"price": 106.1, "symbol": "AAPL"}

data: {"price": 107.8, "symbol": "AAPL"}
```

핸드 쉐이킹 과정후 하나의 TCP연결을 계속 유지하기에 서버 부담이 적다. 또한 서버의 첫번째 이후 HTTP 헤더가 필요없다. 클라이언트 측에서 javaScript의 Event Source 객체를 사용해서 반응하면 된다.

연결이 비정상적으로 끊어졌을경우 EventSource 객체에서 재연결 응답 요청을 보낸다. 이때 Last-Event-ID 필드를 통해서 언제 마지막으로 끊겼는지 보내줌.

- HTTP기반이기에 방화벽에도 친화적. 원래 열려있는 80번이나 443번 포트를 그대로 사용하기에 WebSocket처럼 따로 포트 설정 안해줘도 된다.


- Chrome에서는 최대 6개의 SSE 연결만 유지 가능.HTTP2로는 100개가 기본




## 🤔 초당 1000개 이상의 주가 업데이트에서 WebSocket이 더 적합한 이유

**즉 이 부분은 트래픽이 많을 경우**

사실 이 부분은 여러가지 의견이 있을 것 같기도하다. 개인적인 생각으론 두 가지 측면에서 WebSocket이 더 적합하다고 생각합니다. (틀릴수도 있어용)

### 1. 데이터 전송

SSE는 단순한 문자열(텍스트)만 전송 가능

WebSocket은 바이너리 데이터(이미지, 동영상, JSON 등)를 효율적으로 전송 가능

실제로 SSE는 한번 연결후 HTTP 헤더없이 메시지만으로도 통신이 가능하여 오버헤드가 상대적으로 WebSocket보다는 적습니다. 하지만 

- 이미지, 동영상 같은 바이너리 데이터를 전송할 수 없음.
- JSON도 문자열로 변환해야 하므로 오버헤드가 발생할 수 있음.
- 데이터 크기가 커지면 문자열 인코딩으로 인해 비효율적일 수 있음.

| 전송 방식                      | 텍스트 (JSON, Base64)             | 바이너리 (Raw Data)   |
| ------------------------------ | --------------------------------- | --------------------- |
| **데이터 크기**                | 인코딩 오버헤드로 증가 (최대 33%) | 원본 크기 유지        |
| **처리 속도**                  | 인코딩/디코딩 필요 (CPU 부담)     | 바로 사용 가능 (빠름) |
| **대용량 파일 (이미지, 영상)** | Base64 변환 시 33% 크기 증가      | 그대로 전송 가능      |
| **숫자 데이터 (정수, 실수)**   | 텍스트 변환 시 크기 증가          | 4~8바이트로 압축 가능 |


**이러한 이유로 WebSocket이 실무 상황에선 유리하다고 생각합니다**

물론 케이스에 따라서 단순한 텍스트만 보내주는 경우에는 SSE가 더 적합할 것입니다.

### 2. HTTP 부하

SSE는 클라이언트당 1개의 TCP 연결을 유지하지만, 클라이언트가 요청을 보낼 때마다 새로운 HTTP 요청을 만들어야 함.

WebSocket은 한 개의 TCP 연결 내에서 양방향 통신이 가능하므로, 새로운 HTTP 요청을 만들 필요가 없음.

즉 WebSokcet은 클라이언트의 요청 처리를 새로운 HTTP 연결 생성없이 처리가 가능하기 때문입니다.

# 📞 HTTP 0.9 1.0 1.1 2.0

*인파님의 블로그와 여러가지 구글링을 통해서 정리한 글입니다.*

## HyperText Transfer Protocol

원래는 HTML 문서를 전송하기 위한 통신 프로토콜.

클라이언트와 서버간의 이루어지는 상호대화를 위한 요청-응답 프로토콜.

## HTTP 0.9

가장 단순한 형태로 HTML문서를 GET하기위한 용도였다.

상태코드도 없고 헤더가 없다.

## HTTP 1.0

GET, HEAD, POST 3개의 메소드가 존재했다.

0.9와 다르게 인터넷 세상이 발전하면서 단순한 HTML 문서 뿐만아니라 여러 형태의 데이터들이 많아지면서 등장하게되었다.

- 요청,응답의 헤더가 존재 
  - 상태코드가 존재함, 상태코드로 클라이언트 사이드에서 처리 가능

**단기 커넥션 문제**

HTTP 1.0은 Connectionless 비연결성 특징으로 커넥션이 하나의 요청에 하나의 응답처리만 가능했다.

그렇기에 HTML,CSS,JS 등 여러 자원을 요청하면, 이미지등 다양한 자료당 하나씩 연결이 생기고 종료되어 부하가 증가하여 느렸다.

## HTTP 1.1 


HTTP는 1.0의 여러가지를 보완해서 6개월뒤에 출시되었다.

---

### Request 

1: **Request line**
```http
GET /index.html HTTP/1.1
```
메서드/ 요청 대상(request url)/ http 버전 

2: **헤더**

key : value 형식
```http
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
Accept: text/html,application/xhtml+xml,application/xml;q=0.9
Connection: keep-alive
```
3: **메시지 바디**



### Response 

1: **Status Line**
```http
HTTP/1.1 200 OK
```
http 버전/ 상태 코드/ 상태 메세지

2: **Header** 
```http
Date: Wed, 03 Apr 2025 12:00:00 GMT
Server: Apache/2.4.41
Content-Type: text/html; charset=UTF-8
Content-Length: 1024
Connection: keep-alive
```

3: **메시지 바디**

---

### 🤔 Persistent Connection

기존의 HTTP 는 Connectionless 특징으로 인해 매번 요청마다 새롭게 TCP 연결을 해야된다.

하지만 헤더에 Connection : keep-alive로 보내면 연결이 유지된다. 

```http
GET /index.html HTTP/1.1
Host: www.example.com
Connection: keep-alive
Keep-Alive: timeout=5, max=100
```

클라이언트가 이런식으로 요청을 보내면 하나의 연결에서 최대 100개의 요청 처리가 가능하고, 5초간 별다른 요청이 없을 경우 연결이 끊어지는 것이다.

### 📕 파이프 라이닝

여러개의 요청을 보낼때 순서대로 응답을 기다리지말고 요청을 한꺼번에 보내는 방식이다.

TCP에서는 패킷의 순서를 보장하기에 대부분 브라우저에서 막는다. 그렇기에 파이프라이닝은 실제로 안된다.

응답 순서를 지키기 위해서 응답 처리를 미루는 **Head of Line Blocking** 문제가 존재

> HTTP 2에서 멀티플렉싱으로 대체됨

### 도메인 샤딩 (domain sharding)

도메인 (Domain):
도메인은 인터넷 상에서 웹사이트를 식별하는 고유한 주소입니다.

HTTP 1.1에서는 한 도메인이 동시에 열수있는 TCP 연결수에 제한이 있다. 그렇기에 제한된 숫자보다 더 많은 리소스를 다운로드 받기 위해서 **하나의 도메인을 여러개의 하위 도메인으로 분할한다**

이게 도메인 샤딩이다.

예를 들어, www.example.com 대신 img1.example.com, img2.example.com 등으로 나누어 리소스를 요청할 수 있습니다.

기본적으로 도메인을 2~3개 정도로 분할하고, 4개가 넘어가면 오히려 성능이 떨어진다고 합니다.

그 이유로는 DNS Look up 시간이 있습니다. 여러개의 도메인으로 나뉘기에 각 도메인마다 look up시간이 소요되기 때문입니다.

보통은 브라우저 캐시에 캐싱이 되기 때문에 자주 변경되지 않는 정적 웹사이트에서는 유용하지 않는다. 이미지가 자주 업데이트되고 많은 수의 이미지가 단일 페이지에 존재하는 동적 웹사이트에 적합하다.

## ⚠️ 1.1의 한계

> 1.1은 TCP 연결의 대표적인 Head of Line Blocking 문제와 쓸데없이 헤더가 크고 중복된다는 문제가 있습니다.


##  🆚 HTTP 2.0

1.1을 개선한 것이 2.0 버전이고 현재 네이버나 구글 등 2.0을 더 많이 쓴다고 합니다.

실제로 개발자도구를 켜서 protocol을 보면 대부분 2.0이더라고요.

1.1과의 차이점을 중심으로 보겠습니다.

### Ⓜ️ 메시지 전달 방식의 차이

http 1.1에서는 메시지가 TEXT 형식으로 전달되었다.

메시지들을 \r 같은 개행문자로 구분이 되었고, 바디는 압축되지만 헤더는 압축되지 않는 문제가 있었다.

2.0부터는 헤더와 바디가 layer로 구분이되며 더 안전해진것이다.

> Binary frame으로 인코딩되어 전송된다.

**Frame**

: http/2의 최소단위며, header 혹은 data가 들어있다.

**Message**

: 요청과 응답의 단위로 다수의 frame으로 이루어져있다.

**Stream**

: 연결된 커넥션에서 양방향으로 Message를 주고 받는 하나의 흐름.

그림으로 보는게 이해가 빠릅니다. 인파님 블로그 참조 

결국 단위로 보자면 frame - message - stream - connection 순이고, 하나의 커넥션안에 여러개의 stream이 병렬적으로 처리되어 속도가 빠른 것이다.

### 😁 MultiPlexing

하나의 커넥션으로 여러개의 메세지 스트림을 응답 순서에 상관없이 주고 받는 것을 의미합니다.

1.1과 2.0의 차이도 역시 그림으로 보면 이해가 빠른 것 같습니다.

### 🤝 Server push 

원래는 클라이언트가 요청해야지 서버가 응답하는 구조였다.

서버가 먼저 데이터를 보낼수 없었는데, 2.0에서는 클라이언트가 필요할 것 같은 리소스를 먼저 보낼수있다.

그럼으로 추후의 미래에 필요할 것 같은 리소스를 클라이언트의 브라우저 캐시로 보내놔서 성능을 향상 하는 것이다.

> **스트림 우선 순위**
> 
> 하지만 하나의 연결에 여러 요청과 응답이 뒤섞여 버려 패킷 순서가 엉망 징창이 되었다. 따라서 스트림들의 우선순위를 지정할 필요가 생겼는데, 클라이언트는 우선순위 지정 트리를 사용하여 스트림에 식별자를 설정함으로써 해결 하였다.

### 🗜️ 헤더 압축 (Header Compression - HPACK)
HTTP/2는 HPACK이라는 헤더 압축 기술을 사용하여 불필요한 데이터 전송을 줄임

같은 헤더 값을 여러 번 보내지 않고, 압축된 상태로 저장

쿠키나 인증 정보 등으로 인해 커진 헤더 크기를 줄여 네트워크 성능 최적화




[출처1](https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-HTTP-09-HTTP-30-%EA%B9%8C%EC%A7%80-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-%ED%86%B5%EC%8B%A0-%EA%B8%B0%EC%88%A0#http_/_1.1)

[출처2](https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-HTTP-20-%ED%86%B5%EC%8B%A0-%EA%B8%B0%EC%88%A0-%EC%9D%B4%EC%A0%9C%EB%8A%94-%ED%99%95%EC%8B%A4%ED%9E%88-%EC%9D%B4%ED%95%B4%ED%95%98%EC%9E%90)


---



# 오라클의 접속 동작

## 1. 소켓의 동작 이미지 

네트워크 드라이버와 OS의 라이브러리가 송수신을 수행한다. 또한 네트워안에 여러개의 소켓이 존재하기에 
식별 기능이 필요합니다.

식별자가 **주소와 포트번호**의 조합입니다.

### 1: 리스너 기동 

오라클은 수신을 기다리는 프로세스를 **리스너**라고 부릅니다.

listener.ora 파일은 여러개의 데이터베이스를 안내할수 있는 파일입니다.

하지만 보통 하나의 리스너가 한개의 DB를 담당합니다.

> 오라클의 기본 포트 번호는 1521입니다.


리스너가 DB를 인식하는 방법 
- listner.ora 파일 읽기
- 데이터베이스가 자동으로 등록 ( 보통 이 방식 )

### 2: 애플리케이션에서의 커넥션

DB에 연결할 때 필요한 정보를 오라클 클라이언트에 전달해야된다.

그 정보를 **커넥션 디스크립터**라고 한다.

주소와 포트번호가 써있다.

오라클 클라이언트가 tnsnames.ora 파일을 확인해서 리스너의 주소나 포트번호 서비스 이름을 확인한다.

확인한 내용을 사용해서 연결(커넥션)울 확립시킴.

> 서비스명 
>
> 데이터베이스를 식별하기 위해 일반적으로 사용하는 이름 

### 3: 서버 프로세스의 생성

리스너는 소켓이 확립되면 서버 프로세스를 생성해서 소켓을 전달해준다.

일부 OS에서는 소켓을 공유하는 경우도 있음.

리스너가 SQL을 처리할 수 있지만 그러면 다른 처리가 안되기에 전담 영업자에게 전달하는 것이라고 보면됩니다.

### 서버 프로세스의 생성 비용

서버 프로세스를 생성하는 과정은 OS에서 메모리를 할당받고, 해당 프로세스가 사용할 전용 메모리인 PGA 할당

또한 SGA에 접근 가능하게 각종 설정을 수행합니다. 이러한 서버 프로세스의 생성까지 포함하여 하나의 커넥션을 생성하는 비용은 0.048초가 걸린다고 합니다.

## 2. 접속 동작의 확인

### 접속 강제로 중지하는 명령어 

TCP/IP 환경을 사용하기에, TCP/IP에서 에러가 반환되지 않으면 오라클은 문제를 눈치 못챈다.

이럴때 명령어로 접속을 끊어줘야합니다.

`alter system kill session ...;` 

## 3. 성능을 개선하기 위해서는?

여기서 커넥션을 맺는 것과 서버 프로세스를 생성하는 것은 오라클에게 무거운 작업이다.

대부분은 커넥션을 맺어놓고 긴시간 사용하지 않습니다. 그렇기에 여러개의 클라이언트 마다 전부 대응하는 커넥션을 생성하여 연결하는 것은 낭비입니다.

그렇다고 하나의 서버 프로세스가 여러개의 클라이언트를 처리하는 것도 무리가 있습니다. 하나의 SQL을 처리하는 동안 다른 클라이언트의 작업을 수행하지 못하기 때문입니다.

그래서 병렬처리를 가능하고 처리량을 높이기 위해서, 오라클은 **공유 서버 구성**이나 **커넥션 풀**이라고 불리는 구성을 사용합니다.

이렇게 되면 서버 프로세스가 상대적으로 클라이언트 프로세스보다 줄어들고, 결과적으론 서버 프로세스가 차지하는 메모리도 줄어들어 성능적으로 좋습니다.

# 요약

- 데이터베이스에 접속하기 위해서는 데이터베이스의 서버의 주소와 리스너의 포트번호가 필요하다.
- tnsnames.ora라는 파일안에 접속하기 위한 정보를 기록해둔다.
- 리스너라고 하는 프로세스가 접속 요청을 받으며, 서버 프로세스의 생성도 같이 수행한다.
- listener.ora 파일 안에는 리스너의 설정을 기록해둔다.(포트)
- 서버 프로세스의 생성은 매우 무거운 작업 이므로 가능하면 줄이는 게 좋다.

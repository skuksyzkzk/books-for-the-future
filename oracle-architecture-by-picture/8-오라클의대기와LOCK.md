# 8. 오라클의 대기와 LOCK

## 🔒 Lock

예를들어 동시에 두명의 클라이언트가 하나의 로우에 접근해서 Select한다음 +1로 update한다고 가정해보자.

그럴경우 둘다 1이라는 값을 select했기에 3으로 업데이트 되는 것이 아니라 2로 유지된다. 갱신 이상이 생긴다.

그렇기에 한 로우에 접근해서 변경을 일으킬때 **LOCK**을 거는 것이다.

> 로우 Lock은 Lock을 건 세션에서 커밋 또는 롤백이 수행될때 해제됩니다.

## DML

Update와 같은 DML은 자동으로 로우 Lock을 걸기 때문에 문제가 발생하지 않으며, 병렬로
처리를 하더라고 정상처리된다.

**그렇기에 대량으로 id = 1인 로우를 Update치면 Lock을 얻기위한 Lock 대기 시간이 필연적으로 발생하게 됩니다**


## 대기와 Lock 대기

### 대기와 대기 이벤트

대기는 실제로 기다리는 것이다.

대기 이벤트는 기다리게 만든 작업입니다.

## Idle 대기

처리할 것이 없어서 쉬고 있는 대기

**SQL의 처리를 기다리게 하지 않아도 된다**

일반적으로 신경 안써도 됨

## Non-Idle 대기

이유가 있어서 어쩔 수 없이 하는 대기

- 디스크 I/O 대기
- 오라클은 SQL 처리 도중에 데이터가 필요할 때는 디스크에서 블록을 읽어오면 대기가 발생합니다.


이상 상태등 쓸데없이 SQL을 기다리게 하는 대기 

- 이 대기는 판단하기 어렵습니다.
- 누군가 테이블에 LOCK을 걸고 식사를 하러 가버린 경우 등

### 튜닝 관점

SQL 처리 시간 = Non-Idle 대기 이벤트 + SQL 처리에 사용하는 CPU 시간


## Lock에 의한 대기는 ?

사실 Lock을 건다고 무조건 대기가 발생하는 것이 아니라 Lock 걸린 대상의 Lock을 얻으려고 할 때 대기가 발생한다.

## DeadLock

데드락은 고장난 열쇠라는 의미에서 알 수 있듯이, 서로가 상대방이 보유하는 Lock을 얻으려고 하느라 작업이 영원히 진행 안되는 상태입니다.

`ORA-00060` 데드락 상황일때는 한쪽의 처리가 오라클에 의해 자동으로 롤백되고 alert 파일과 트레이스 파일 `orcl_ora_8339.trc`에 정보가 표시되어 

데드락을 발생시킨 SQL을 확인하여 수정할 수 있게됩니다.


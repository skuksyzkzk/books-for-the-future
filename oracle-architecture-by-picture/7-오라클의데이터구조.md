# 7. 오라클의 데이터 구조

## 🚩 서론 

오라클은 전달 받은 데이터를 그대로 저장하지 않고 상자에 담아서 저장한다고 했습니다. 이와 관련된 용어를 알아보겠습니다.

- 테이블스페이스
- 세그먼트
- 익스텐트(extent)
- 블록
- 데이터파일

### 가변 길이 데이터를 관리하는 프로그램

가변 길이의 데이터를 관리하는 프로그램을 만든다고 생각해보십쇼. 만약 abcde , 1234 이런데이터를 그냥 넣는데로 순서대로 저장한다면 각 데이터 뒤에 새롭게 데이터를 삽입하려고 할 때 문제가 발생할 것입니다.

또한 두 개 데이터를 동시에 수정하면, 동시성 문제가 발생합니다.

> 예시로 100만건이라고 가정할 경우 데이터를 차례대로 저장하면 100만개의 관리가 필요합니다.

그래서 데이터를 관리하기 위해서 **특정한 크기로 뭉쳐서 관리합니다**

예를들어 1만개씩 관리한다고 하면 100개의 관리정보만 있으면 되고, I/O의 횟수도 100회로 충분할 것입니다.

<img width="447" alt="image" src="https://github.com/user-attachments/assets/6c881f8b-fd60-4d7c-a10f-aac0aa33d56d" />


### 최종적으로 고려해야할 것
- 관리 및 IO의 효율을 고려해서 데이터를 특정 크기로 관리
- 데이터 변경에 필요한 공간을 확보
- 비어있는 공간을 관리한다.

## 🗜️ 1. 오라클의 데이터 구조 

![image](https://github.com/user-attachments/assets/86655581-656b-4ff3-964d-7f2d6f74fc48)


오라클의 데이터 구조는 논리 구조/물리 구조로 나눌수 있습니다. 

물리구조에는 데이터파일과 블록이 있습니다. OS에서 보이는 구조를 의미합니다.

### 🅱️ 가장 작은 단위 : 블록

블록은 보통 8KB로 이루어져있습니다.

블록은 블록을 관리하기 위한 공간과 데이터가 입력되는 빈공간으로 나뉩니다.

> LOB같은 데이터형은 다른 장소에 보관하기도 합니다.

우리가 알고있는 **로우**는 블록에 저장됩니다.

또한 블록은 데이터 변경에 대비한 공간을 남겨둡니다.

> 🗽PCTFREE
>
> 이 임계치에 도달하면 이 블록에 입력하는 것을 멈추고 이 블록의 공간은 꽉찼다고 인식합니다.
>
> Ⓜ️PCTUSED
>
> 이 임계치보다 작아지면 이 블록은 비어있다고 인식합니다.

-> 이러한 정보는 세그먼트 단위로 관리합니다.

세그 먼트에 공간이 부족하면 익스텐드를 새롭게 추가하여 빈블록을 늘립니다.

> 😁 ROWID 
>
> 데이터 파일의 번호,블록의 번호, 로우 번호로 구성되어 있습니다. 실제로 로우의 주소를 의미합니다.

### 📲 익스텐드 

테이블 역시 여러개의 블록들로 이루어져있지만 블록을 단위로 관리하지는 않습니다.

#### 익스텐드는 "연속된" 블록의 집합입니다.

그렇기에 익스텐드의 시작위치와 블록의 갯수만 알면 관리가 가능합니다. 


### 📕 세그먼트

여기서 테이블이나 인덱스 등의 데이터를 한번 더 모은 익스텐드의 집합이 **세그먼트**입니다.

세그먼트는 구조입니다. 데이터베이스 내에서 존재하는 것 처럼 보이기 때문입니다.

실제로 오라클 내에는 사용자의 세그먼트 이외에도 오라클이 자동으로 생성하는 세그먼트들도 있습니다. UNDO라고 불리는 과거 데이터를 보관하는 세그먼트 같은 것.


### 🪟 테이블 스페이스

이것도 역시 내부의 구조. 세그먼트를 분류해서 보관하기 위한 상자라고 보면 편합니다.

**테이블 스페이스는 한 개 이상의 데이터 파일로 구성**

> 테이블 스페이스의 집합 + REDO 로그 파일 + 컨트롤 파일 = 하나의 DB 

## 📞 2. 서버 프로세스가 본 데이터 구조

### SELECT 

이 과정에서 서버 프로세스는 우선 해당 테이블의 익스텐드를 조사하고 버퍼캐시에 존재하지 않는 블록은 처음부터 읽어 옵니다.

### UPDATE

데이터의 변경과정에서 인덱스를 사용한다면, 해당 인덱스의 루트 블록을 찾아가고 버퍼캐시에 없다면 인덱스 정보가 있는 익스텐드를 읽어옵니다.

"그 다음 루트 블록에서 다음 블록의 주소 조사 + 없다면 읽어오기"

이 과정을 반복하여 블록의 데이터를 읽어오고 

**캐시 상**에서 블록의 데이터를 변경합니다.

여기서 중요한 것은 캐시 데이터를 변경하는 것입니다.(디스크(데이터파일)가 아니라)

그 후 백그라운드 프로세스인 DBWR이 데이터 파일에 변경 내용을 기록합니다.

# 🗽 요약

- 테이블 스페이스는 세그먼트를 집어넣기 위한 용기로서 하나 이상의 데이터 파일로 구성된다.
- 일반적으로 테이블이나 인덱스는 세그먼트다.
- 세그먼트는 익스텐드로 구성되며, 익스텐드는 연속된 블록으로 구성되어있다.
- 세그먼트는 테이블 스페이스 여러개에 **걸쳐서** 존재 할 수 없다.
- 익스텐트는 데이터 파일 여러개에 걸쳐서 존재할 수 없다.
  - 연속된 블록이므로
- 일반적으로 테이블이나 인덱스는 테이블 스페이스가 가지고 있는 공간에서 새로운 익스텐트를 할당받음으로써 크기가 커진다.
- 블록 안의 데이터 변경용 공간은 PCTFREE라는 파라미터로 제어한다.
- 로우(행)은 블록에 보관되어있다.

